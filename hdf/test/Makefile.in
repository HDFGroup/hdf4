# ****************************************************************************
# * NCSA HDF                                                                 *
# * Software Development Group                                               *
# * National Center for Supercomputing Applications                          *
# * University of Illinois at Urbana-Champaign                               *
# * 605 E. Springfield, Champaign IL 61820                                   *
# *                                                                          *
# * For conditions of distribution and use, see the accompanying             *
# * hdf/COPYING file.                                                        *
# *                                                                          *
# ****************************************************************************
#
# $Id$
#
# ##################################################################
#
#                          ABOUT THIS MAKEFILE
#
# This makefile creates HDF test programs.  There are three categories
# of test programs:
#
#              application layer C test programs
#              application layer FORTRAN test programs
#              lower level C test programs
#
# The application layer C test programs are:
#
#          trig    (8-bit, 24-bit raster image sets and palette interface)
#          tsdnt  (scientific data sets, data only)
#          tsdnnt (same as tdfsd_nt with native number types)
#          tsdmms (scientific data sets, data, max/min and scales)
#          tsdnmms(same as tdfsd_mms with native number types)
#          tsdstr (data and dimension strings: label, unit, format and coordsys)
#          tan     (annotations for HDF objects)
#          tanfile (annotations for HDF files)
#          tstubs  (emulation of old lower level i/o routines)
#
# The application layer FORTRAN test programs are:
#
#          tr8F     (8-bit raster image sets)
#          t24F     (24-bit raster image sets)
#          tpF      (Palettes)
#          tsdntF   (scientific data sets, data only)
#          tsdnntF  (same as tdfsd_nntF except all data types are native
#                           machine number types)
#          tsdmmsF  (scientific data sets, data, max/min and scales)
#          tsdnmmsF (same as tdfsd_mmsF with native number types)
#          tsdstrF  (data and dimenstrings: label, unit, format and coordsys)
#          tanF     (annotations for HDF objects)
#          tanfileF (annotations for HDF files)
#          tstubsF  (emulation of old lower level i/o routines)
#
# Vset test programs:
#
#          tvset.c  (the basic vgroup and vdata creation routines)
#          tvsfpack.c (pack/unpack field values into/from a vdata buf)
#          egfhi.f  (Fortran version of egchi.c)
#          tvsetf.f (Fortran version of tvset.c)
# The lower level C test programs are:
#
#              vers.c     (get version string from an HDF file)
#              thfile     (basic i/o)
#              terr       (error handling)
#              thblocks   (linked blocks)
#              thextelt   (i/o involving external files)
#              tvers      (storing and retrieving version strings)
#              thlinkage  (linkage of functions)
#
# Hyperslab C test programs
#              slabw      (write data as 5 slabs )
#              slab1w     (write data as first 3 of 5 slabs )
#              slab2w     (write data as last 2 of 5 slabs )
#              slab3w     (write data as 24 slabs i.e. each element )
#              slab4w     (write data as 1 slab )
#              slabwf     (write data as 5 slabs )
#
# Hyperslab Fortran test programs
#              slabw      (write data as 5 slabs )
#              slab1wf    (write data as first 3 of 5 slabs )
#              slab2wf    (write data as last 2 of 5 slabs )
#              slab3wf    (write data as 24 slabs i.e. each element )
#              slab4wf    (write data as 1 slab )
#
# ##################################################################
#
#                      HOW TO USE THIS MAKEFILE
#
# You need libdf.a to compile any of these test programs.  You will
# also need selected header files as described below.
#
# To compile the application layer C test programs, enter "make ctests".
# If there are test programs that you do not want to compile, do this
# by removing them from the lines "COBJS=" and "CSRCS=" below.
# You need access to the header files indicated in the "CHDRS=" line
# below to compile these programs.
#
# To compile the application layer FORTRAN test programs, enter
# "make ftests".  You need access to the header files indicated in
# the "FHDRS=" line below to compile these programs.
# If there are test programs that you do not want to compile, do this
# by removing them from the lines "FOBJS=" and "FSRCS=" below.
#
# To compile the lower level C test programs, enter "make htests".
# You need access to the header files indicated in the "HHDRS=" line
# below to compile these programs.  If there are test programs that
# you do not want to compile, do this by removing them from the lines
# "HOBJS=" and "HSRCS=" below.
#
# To remove all object files created by this makefile, enter "make clean"
#
# ##################################################################
#
#                       PORTING INSTRUCTIONS
#
# You must modify the lines containing the symbol "==>" to make
# this makefile compatible with your platform.
#
# ##################################################################

### Start of system configuration section. ####
# Set shell so we know what it is
SHELL = /bin/sh

# 'srcdir' Gets set to directory this Makefile is found in
srcdir = .
TOP_SRCDIR = ../..

prefix = $(TOP_SRCDIR)/NewHDF

exec_prefix = $(prefix)
tooldir = $(exec_prefix)/$(target)

program_transform_name =

datadir = $(prefix)/lib
mandir = $(prefix)/man
man1dir = $(mandir)/man1
man2dir = $(mandir)/man2
man3dir = $(mandir)/man3
man4dir = $(mandir)/man4
man5dir = $(mandir)/man5
man6dir = $(mandir)/man6
man7dir = $(mandir)/man7
man8dir = $(mandir)/man8
man9dir = $(mandir)/man9
docdir = $(datadir)/doc

INSTALL = $${srcroot}/install.sh -c
INSTALL_PROGRAM = $(INSTALL)
INSTALL_DATA = $(INSTALL) -m 644

# /usr/local/bin/m4 (GNU version?)
M4   = /usr/local/bin/m4
# /usr/local/bin/perl (GNU version?)
PERL = /usr/local/bin/perl

# Name of achive randomizer, usually ranlib (use 'touch' if non-existant)
RANLIB = ranlib

# Name of library archiver and flags to send, default 'AR=ar', 'ARFLAGS=r'
AR = ar
ARFLAGS = r

# Name of remove utility, default 'RM=/bin/rm', 'RMFLAGS=-f'
RM = /bin/rm
RMFLAGS = -f

#Compilier defaults overriden by top level make
AS = as
CC = gcc
CFLAGS = -ansi
FC = f77
FFLAGS=

# Set for document generation
MAKEINFO = makeinfo
TEXI2DVI = texi2dvi

# Directory in which to install scripts.
bindir = $(exec_prefix)/bin

# Directory in which to install library files.
libdir = $(prefix)/lib

# Directory in which to install documentation info files.
infodir = $(prefix)/info

#### ----- host and target specific makefile fragments come in here.-------
### ------------------- end of makefile fragments -------------------------

# ############# End of system configuration section. ###############

HDF_FLAGS       = \
        CC="$(CC)" \
        CFLAGS="$(CFLAGS)" \
        FC="$(FC)" \
        FFLAGS="$(FFLAGS)" \
        RANLIB="$(RANLIB)" \
        AR="$(AR)" \
        ARFLAGS="$(ARFLAGS)" \
        RM="$(RM)" \
        RMFLAGS="$(RMFLAGS)" \
        MACHINE="$(MACHINE)" 

LOCAL_MACROS  = CC="$(CC)" \
	CFLAGS="$(CFLAGS)" \
	CPP="$(CPP)" \
	CPPFLAGS="$(CPPFLAGS)" \
	exec_prefix="$(exec_prefix)" \
	FC="$(FC)" \
	prefix="$(prefix)"

# ==> where is your HDF library (libdf.a) located?
# ==> where are your hdf.h, hdfi.h and vg.h files located?
HDFINC= $(srcdir)/../src
HDFLIB=$(srcdir)/../src
HDFSRC=$(srcdir)/../src
HDFBIN=$(srcdir)/../bin

# ==> where is your JPEG library (libjpeg.a) located?
JPEGLIB=$(srcdir)/../jpeg
JPEGINC=$(srcdir)/../jpeg

# ==> where is your PABLO include files
PABLO_HINC= $(srcdir)/../pablo

# ==> specify where to find the FMPOOL include and source files 
FMPOOL_INC=$(srcdir)/../fmpool
FMPOOL_SRC=$(srcdir)/../fmpool

# ==> where is your zlib library (libzlib.a) located?
ZLIBLIB=$(srcdir)/../zlib
ZLIBINC=$(srcdir)/../zlib

ALL_CFLAGS = $(CFLAGS) $(FMPOOL_FLAGS) -I$(HDFINC) -I$(JPEGINC) -I$(ZLIBINC)

MANIFEST = $(DISTFILES)

DISTFILES = Makefile.in bitio.dat litend.dat nbit.dat tmgr.dat win32tst.mak \
	$(CSRCS) $(FSRCS) $(CHDRS) gentest.c

CHDRS= tproto.h tutils.h

CSRCS= 	rig.c sdstr.c blocks.c an.c anfile.c extelt.c file.c file1.c vers.c \
	sdmms.c sdnmms.c slab.c litend.c tvset.c comp.c bitio.c tree.c conv.c \
	nbit.c man.c mgr.c testhdf.c tbv.c tvsfpack.c

COBJS= rig.o sdstr.o blocks.o an.o anfile.o extelt.o file.o file1.o vers.o \
	sdmms.o sdnmms.o slab.o litend.o tvset.o comp.o bitio.o tree.o conv.o \
	nbit.o man.o mgr.o testhdf.o tbv.o tvsfpack.o

FSRCS= fortest.c fortestF.f forsupff.f forsupf.c \
	manf.f mgrf.f slabwf.f t24f.f tanf.f tanfilef.f tpf.f tr8f.f \
	tsdmmsf.f tsdnmmsf.f tsdnntf.f tsdntf.f tsdstrf.f tstubsf.f tvsetf.f

FOBJS = fortestF.o forsupff.o forsupf.o \
	manf.o mgrf.o slabwf.o t24f.o tanf.o tanfilef.o tpf.o tr8f.o \
	tsdmmsf.o tsdnmmsf.o tsdnntf.o tsdntf.o tsdstrf.o tstubsf.o tvsetf.o

#CFORSUPSRCS = forsupf.c

FTESTS = fortest fortestF

#CFORSUPOBJS = forsupf.o

TESTF = fortest.o

# directory used by extelt test.
TESTDIR = testdir

all::		FORCE
	@case "$(FC)" in \
	NONE*|none*) \
	    $(MAKE) $(MFLAGS) $(HDF_FLAGS) nofortran ;; \
	*) \
	    $(MAKE) $(MFLAGS) $(HDF_FLAGS) rall ; \
	esac

rall::         FORCE
	@if test -z "$(FMPOOL_FLAGS)"; then \
	  $(MAKE) $(MFLAGS) $(HDF_FLAGS) testhdf fortest fortestF gentest; \
	else		 \
	  $(MAKE) $(MFLAGS) $(HDF_FLAGS) FMPOOL_FLAGS="$(FMPOOL_FLAGS) -I$(FMPOOL_INC)" testhdf fortest gentest; \
	fi

nofortran::         FORCE
	@if test -z "$(FMPOOL_FLAGS)"; then \
	  $(MAKE) $(MFLAGS) $(HDF_FLAGS) testhdf gentest; \
	else		 \
	  $(MAKE) $(MFLAGS) $(HDF_FLAGS) FMPOOL_FLAGS="$(FMPOOL_FLAGS) -I$(FMPOOL_INC)" testhdf gentest; \
	fi

rebuild:
	@$(MAKE) all $(HDF_FLAGS) FRC=force_rebuild

rebuildnofortran:
	@$(MAKE) nofortran $(MFLAGS) $(HDF_FLAGS) FRC=force_rebuild

# Leave this target blank with no actions, the rebuild macros above depend on it
force_rebuild:

debug: ptesthdf

$(HDFLIB)/libdf.a:
#	cd $(HDFLIB); echo Making \`$(TARG)\' in `pwd`; \        
#	$(MAKE) $(MFLAGS) $(HDF_FLAGS) $(TARG); 

$(JPEGLIB)/libjpeg.a:
#	cd $(JPEGLIB); echo Making \`$(TARG)\' in `pwd`; \        
#	$(MAKE) $(MFLAGS) $(HDF_FLAGS) $(TARG); 

$(ZLIBLIB)/libz.a:
#	cd $(JPEGLIB); echo Making \`$(TARG)\' in `pwd`; \        
#	$(MAKE) $(MFLAGS) $(HDF_FLAGS) $(TARG); 

#.c.o: 
#	 $(CC) $(CFLAGS) -c -I$(HDFINC) $*.c 
#
.c.o: 
	$(CC) $(ALL_CFLAGS) -c $*.c 

.f.o:
	$(FC) $(FFLAGS) -c $*.f 

$(COBJS) $(TESTF) $(FTESTS): $(FRC)

$(FOBJS): fortest.inc

#$(FTESTS): $(FOBJS) $(CFORSUPOBJS) $(FFORSUPOBJS) $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a
#	$(FC) $(FFLAGS) $@.o -o $@ $(CFORSUPOBJS) $(FFORSUPOBJS) $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

#$(FTESTS): $(FRC)

test-hdf::		FORCE
	@case "$(FC)" in \
	NONE*|none*) \
	    $(MAKE) $(MFLAGS) $(HDF_FLAGS) test-hdfnofortran ;; \
	*) \
	    $(MAKE) $(MFLAGS) $(HDF_FLAGS) atest-hdf ; \
	esac

atest-hdf: testhdf fortest
	-$(RM) $(RMFLAGS) *.hdf 
	./testhdf
	-$(RM) $(RMFLAGS) *.hdf 
	./fortest

test-hdfnofortran: testhdf
	-$(RM) $(RMFLAGS) *.hdf 
	./testhdf

test-hdffortran: fortest fortest.sav
	-$(RM) $(RMFLAGS) *.hdf 
	./fortest > fortest.out
	@cmp fortest.out fortest.sav && echo "*** Fortran tests passed ***";

qtesthdf: $(COBJS) $(HDFLIB)/libdf.a
	quantify $(CC) $(ALL_CFLAGS) -o qtesthdf $(COBJS) $(HDFSRC)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

ptesthdf: $(COBJS) $(HDFLIB)/libdf.a
	purify $(CC) $(ALL_CFLAGS) -o ptesthdf $(COBJS) $(HDFSRC)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

testhdf.tc: $(COBJS) $(HDFLIB)/libdf.a
	proof $(CC) $(ALL_CFLAGS) -o testhdf.tc $(COBJS) $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

testhdf: $(COBJS) $(HDFLIB)/libdf.a
	$(CC) $(ALL_CFLAGS) -o testhdf $(COBJS) $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a
	test -d $(TESTDIR) || mkdir $(TESTDIR)

fortestF: $(FOBJS) $(HDFLIB)/libdf.a
	$(FC) $(FFLAGS) -o $@ $(FOBJS) $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

fortest: $(HDFLIB)/libdf.a fortest.c $(CHDRS)
	$(CC) $(ALL_CFLAGS) -o fortest fortest.c $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

gentest: gentest.c $(HDFLIB)/libdf.a
	$(CC) $(ALL_CFLAGS) gentest.c -o gentest $(HDFLIB)/libdf.a $(JPEGLIB)/libjpeg.a $(ZLIBLIB)/libz.a

ftests: $(FTESTS)

clean: 
	-$(RM) $(RMFLAGS) $(COBJS) testhdf $(FOBJS) $(FTESTS) \
	core *.hdf ptesthdf qtesthdf gentest *.o fortest.arg $(TESTDIR)/*

distclean: 
	-$(RM) $(RMFLAGS) $(COBJS) testhdf $(FOBJS) $(FTESTS) \
	core *.hdf ptesthdf qtesthdf gentest *.o fortest.arg $(TESTDIR)/* \
	config.status Makefile

depend: 
	makedepend -I$(HDFINC) *.c

saber:	$(CSRCS)
	 #load $(ALL_CFLAGS) $(CSRCS) 

# for distribution creation
distdir = $(TOP_SRCDIR)/$(PACKAGE)-$(VERSION)/$(curdir)
curdir = hdf/test
dist: $(DISTFILES)
	@for file in $(DISTFILES); do \
	  ln $(srcdir)/$$file $(distdir)/$$file 2> /dev/null \
	    || { echo copying $$file instead; \
	    cp -p $(srcdir)/$$file $(distdir)/$$file;}; \
	done

# The following dummy target is useful as a dependency to ensure that a
# rule is always executed.
#
FORCE:

help:
	@echo ""
	@echo "Make supports the following targets in the 'tests' directory"
	@echo "make help    - prints this usage section"
	@echo "make all     - (DEFAULT) makes tests"
	@echo "make nofortran - makes HDF tests excluding fortran tests"
	@echo "make testhdf   - makes HDF C test program "
	@echo "make fortest   - makes HDF Fortran test program "
	@echo "make test-hdf          - run HDF tests " 
	@echo "make test-hdfnofortran - run HDF tests except the fortran test " 
	@echo "make test-hdffortran   - run HDF fortran tests only " 
	@echo "make clean     - cleans up tests (both C and Fortran)"
	@echo "make distclean - cleans up HDF tests including"
	@echo "                 configuration(Makefiles,config.status,..)"
	@echo ""

# DO NOT DELETE THIS LINE -- make depend depends on it.
